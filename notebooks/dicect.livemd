# Dicect Notebook

```elixir
Mix.install(
  [
    {:dicect, path: Path.join(__DIR__, ".."), env: :dev}
  ],
  config_path: :dicect,
  lockfile: :dicect
)
```

## Shared

```elixir
alias Dicect.Die
alias Dicect.Probability

alias VegaLite, as: Vl
alias Kino.VegaLite, as: KV
```

```elixir
defmodule Scale do
  def scale(data) do
    %{r: min} = data |> Enum.min_by(fn %{r: r} -> r end)
    %{r: max} = data |> Enum.max_by(fn %{r: r} -> r end)

    data
    |> Enum.map(fn %{p: p, r: r} ->
      %{
        p: p,
        r: Scale.scale_number(n: r, data_range: {min, max}, scaled_range: {1, 100})
      }
    end)
  end

  def scale_number(n: n, data_range: {dmin, dmax}, scaled_range: {smin, smax}) do
    (n - dmin) * (smax - smin) / (dmax - dmin) + smin
  end
end
```

## XDY

```elixir
defmodule ForXDY do
  def sum(x, y) do
    start_r = x
    end_r = x * y
    resolutions = start_r..end_r
    
    predicates =
      for(resolution <- resolutions) do
        fn outcome_product_line -> 
          Enum.reduce(outcome_product_line, fn a, b -> a + b end) == resolution 
        end
      end

    result = Probability.calculate([{Die.new(y), x}], predicates)
    resolutions |> Enum.zip(result) |> Enum.map(fn {x, y} -> %{r: x, p: y} end)
  end
end
```

## 2D6

```elixir
chart =
  Vl.new(width: 400, height: 400)
  |> Vl.mark(:bar)
  |> Vl.encode_field(:x, "r", type: :quantitative)
  |> Vl.encode_field(:y, "p", type: :quantitative)
  |> KV.render()

KV.push_many(chart, ForXDY.sum(2, 6))
```

## 3D6

```elixir
chart =
  Vl.new(width: 400, height: 400)
  |> Vl.mark(:bar)
  |> Vl.encode_field(:x, "r", type: :quantitative)
  |> Vl.encode_field(:y, "p", type: :quantitative)
  |> KV.render()

KV.push_many(chart, ForXDY.sum(3, 6))
```

## Compare XD6

```elixir
sum2d6 = 
  ForXDY.sum(2, 6)
  |> Scale.scale()
  |> Enum.map(fn %{p: p, r: r} -> %{p2d6: p, r2d6: r} end)

sum3d6 = 
  ForXDY.sum(3, 6)
  |> Scale.scale()
  |> Enum.map(fn %{p: p, r: r} -> %{p3d6: p, r3d6: r} end)

sum4d6 = 
  ForXDY.sum(4, 6)
  |> Scale.scale()
  |> Enum.map(fn %{p: p, r: r} -> %{p4d6: p, r4d6: r} end)
```

```elixir
chart =
  Vl.new(width: 400, height: 400)
  |> Vl.layers([
    Vl.new()
    |> Vl.mark(:line, color: "green")
    |> Vl.encode_field(:x, "r2d6", type: :quantitative)
    |> Vl.encode_field(:y, "p2d6", type: :quantitative),
    Vl.new()
    |> Vl.mark(:line, color: "darkblue")
    |> Vl.encode_field(:x, "r3d6", type: :quantitative)
    |> Vl.encode_field(:y, "p3d6", type: :quantitative),
    Vl.new()
    |> Vl.mark(:line, color: "orange")
    |> Vl.encode_field(:x, "r4d6", type: :quantitative)
    |> Vl.encode_field(:y, "p4d6", type: :quantitative)
  ])
  |> KV.render()

KV.push_many(chart, sum2d6 ++ sum3d6 ++ sum4d6)
```

## Ironsworn

```elixir
defmodule ForIronsworn do
  def with_stat(stat) do
    result = 
      Probability.calculate(
        [{Die.new(6), 1}, {Die.new(10), 2}], 
        [
          fn [d6, d10_1, d10_2] -> 
            d6 = d6 + stat
            d6 > d10_1 && d6 > d10_2 
          end,
          fn [d6, d10_1, d10_2] -> 
            d6 = d6 + stat
            (d6 > d10_1 && d6 <= d10_2) || (d6 <= d10_1 && d6 > d10_2) 
          end,
          fn [d6, d10_1, d10_2] -> 
            d6 = d6 + stat
            d6 <= d10_1 && d6 <= d10_2 
          end
        ])
    [:c_strong, :b_weak, :a_miss] 
    |> Enum.zip(result) 
    |> Enum.map(fn {x, y} -> %{r: x, p: y} end)
  end
end
```

```elixir
iron_0 = 
  ForIronsworn.with_stat(0)
  |> Enum.map(fn %{p: p, r: r} -> %{p_0: p, r_0: r} end)

iron_1 = 
  ForIronsworn.with_stat(1)
  |> Enum.map(fn %{p: p, r: r} -> %{p_1: p, r_1: r} end)
  
iron_2 = 
  ForIronsworn.with_stat(2)
  |> Enum.map(fn %{p: p, r: r} -> %{p_2: p, r_2: r} end)

iron_3 = 
  ForIronsworn.with_stat(3)
  |> Enum.map(fn %{p: p, r: r} -> %{p_3: p, r_3: r} end)

iron_4 = 
  ForIronsworn.with_stat(4)
  |> Enum.map(fn %{p: p, r: r} -> %{p_4: p, r_4: r} end)
```

```elixir
chart =
  Vl.new(width: 400, height: 400)
  |> Vl.layers([
    Vl.new()
    |> Vl.mark(:line, color: "lightgreen")
    |> Vl.encode_field(:x, "r_0", type: :ordinal)
    |> Vl.encode_field(:y, "p_0", type: :quantitative),
    Vl.new()
    |> Vl.mark(:line, color: "green")
    |> Vl.encode_field(:x, "r_1", type: :ordinal)
    |> Vl.encode_field(:y, "p_1", type: :quantitative),
    Vl.new()
    |> Vl.mark(:line, color: "pink")
    |> Vl.encode_field(:x, "r_2", type: :ordinal)
    |> Vl.encode_field(:y, "p_2", type: :quantitative),
    Vl.new()
    |> Vl.mark(:line, color: "orange")
    |> Vl.encode_field(:x, "r_3", type: :ordinal)
    |> Vl.encode_field(:y, "p_3", type: :quantitative),
    Vl.new()
    |> Vl.mark(:line, color: "red")
    |> Vl.encode_field(:x, "r_4", type: :ordinal)
    |> Vl.encode_field(:y, "p_4", type: :quantitative)
  ])
  |> KV.render()

KV.push_many(chart, iron_0 ++ iron_1 ++ iron_2 ++ iron_3 ++ iron_4)
```
